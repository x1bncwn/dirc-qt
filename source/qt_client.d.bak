module qt_client;

import qt.core.coreapplication;
import qt.core.coreevent;
import qt.core.namespace;
import qt.core.object;
import qt.core.string;
import qt.core.timer;
import qt.core.variant;
import qt.gui.action;
import qt.gui.color;
import qt.gui.event;
import qt.gui.palette;
import qt.gui.textcursor;
import qt.gui.textoption;
import qt.widgets.application;
import qt.widgets.inputdialog;
import qt.widgets.lineedit;
import qt.widgets.mainwindow;
import qt.widgets.messagebox;
import qt.widgets.treewidget;
import qt.widgets.ui;
import qt.widgets.widget;
import qt.helpers;

import models;
import logging;
import irc_client;

import std.conv;
import std.string;
import std.algorithm;
import std.array;
import std.datetime;
import std.range;
import std.math;
import std.format;
import core.time;
import core.thread;
import std.concurrency;
import std.stdio;

struct QtClientUI
{
    mixin(generateUICode(import("qt_client.ui"), "qt_client"));
}

class QtClient : QMainWindow
{
    mixin(Q_OBJECT_D);

private:
    QtClientUI* ui;

    // State
    string currentDisplay = "System";
    string currentServer;
    string[string] displayBuffers;
    string[] displayHistory;
    string[string][string] channelTopics;

    // Settings
    bool colorizeNicks = true;
    bool autoSwitchToNewChannels = true;
    bool isDarkTheme = true;
    string[string] nickColorCache;

    // IRC Threads
    Tid[string] serverThreads;

public:
    this(QWidget parent = null)
    {
        import core.stdcpp.new_;

        super(parent);
        ui = cpp_new!QtClientUI();
        ui.setupUi(this);

        displayBuffers["System"] = "";

        setupSignals();

        auto timer = cpp_new!QTimer(this);
        timer.setInterval(0);
        QObject.connect(timer.signal!"timeout", this.slot!"onIdleCheck");
        timer.start();

        appendWelcomeMessage();

        ui.statusBar.showMessage(QString("Disconnected"));
    }

    ~this()
    {
        import core.stdcpp.new_;

        disconnectAllServers();
        cpp_delete(ui);
    }

    @QSlot final void onIdleCheck()
    {
        bool gotMessage = true;
        while (gotMessage)
        {
            gotMessage = receiveTimeout(Duration.zero,
                                        (IrcToGuiMessage msg) {
                processIrcMessage(msg);
                return true;
            });
        }
    }

    void sendToIrcThread(string server, GuiToIrcMessage msg)
    {
        if (server in serverThreads)
        {
            send(serverThreads[server], msg);
        }
    }

private:
    void setupSignals()
    {
        import core.stdcpp.new_;

        // Menu actions
        QObject.connect(ui.connectAction.signal!"triggered", this.slot!"onConnectAction");
        QObject.connect(ui.disconnectAction.signal!"triggered", this.slot!"onDisconnectAction");
        QObject.connect(ui.quitAction.signal!"triggered", this.slot!"onQuitAction");
        QObject.connect(ui.darkAction.signal!"triggered", this.slot!"onDarkThemeAction");
        QObject.connect(ui.lightAction.signal!"triggered", this.slot!"onLightThemeAction");
        QObject.connect(ui.aboutAction.signal!"triggered", this.slot!"onAboutAction");

        // Channel selection
        QObject.connect(ui.channelTree.signal!"itemClicked", this.slot!"onChannelSelected");

        // Input
        QObject.connect(ui.inputLine.signal!"returnPressed", this.slot!"sendMessage");
        QObject.connect(ui.sendButton.signal!"clicked", this.slot!"sendMessage");

        // Window close
        QObject.connect(this.signal!"closeEvent", this.slot!"onCloseEvent");
    }

private /+ slots +/:
    @QSlot final void onConnectAction()
    {
        bool ok;
        QString server = QInputDialog.getText(this,
            QString("Connect"),
            QString("Server address:"),
            qt.widgets.lineedit.QLineEdit.EchoMode.Normal,
            QString(defaultServer),
            &ok);

        if (ok && server.length() > 0)
        {
            auto data = server.toUtf8().constData();
            string serverStr = data[0 .. server.toUtf8().length()].idup;
            startConnection(serverStr);
        }
    }

    @QSlot final void onDisconnectAction()
    {
        disconnectFromServer();
    }

    @QSlot final void onQuitAction()
    {
        disconnectAllServers();
        QApplication.quit();
    }

    @QSlot final void onDarkThemeAction()
    {
        setApplicationTheme(true);
    }

    @QSlot final void onLightThemeAction()
    {
        setApplicationTheme(false);
    }

    @QSlot final void onAboutAction()
    {
        string aboutText = "<h2>D IRC Client</h2>" ~
                          "<p>Version 1.0</p>" ~
                          "<p>Qt IRC client converted from GTK</p>";
        QMessageBox.about(this,
            QString("About D IRC Client"),
            QString(aboutText));
    }

    @QSlot final void onCloseEvent(QCloseEvent event)
    {
        disconnectAllServers();
        event.accept();
    }

    @QSlot final void onChannelSelected(QTreeWidgetItem item, int column)
    {
        auto displayData = item.text(0).toUtf8().constData();
        string display = displayData[0 .. item.text(0).toUtf8().length()].idup;

        auto typeData = item.data(0, qt.core.namespace.ItemDataRole.UserRole).toString().toUtf8().constData();
        string itemType = typeData[0 .. item.data(0, qt.core.namespace.ItemDataRole.UserRole).toString().toUtf8().length()].idup;

        currentDisplay = display;

        if (itemType == "server")
        {
            currentServer = display;
        }
        else if (itemType == "channel")
        {
            auto parent = item.parent();
            if (parent !is null)
            {
                auto parentData = parent.text(0).toUtf8().constData();
                currentServer = parentData[0 .. parent.text(0).toUtf8().length()].idup;
            }
        }

        if (display in displayBuffers)
        {
            ui.chatView.setPlainText(QString(displayBuffers[display]));
            scrollToEnd();
        }
    }

    @QSlot final void sendMessage()
    {
        auto textData = ui.inputLine.text().toUtf8().constData();
        string text = textData[0 .. ui.inputLine.text().toUtf8().length()].idup;
        ui.inputLine.clear();

        if (text.length == 0) return;

        if (currentServer.length == 0 || !(currentServer in serverThreads))
        {
            appendSystemMessage("Not connected to any server.");
            return;
        }

        if (text.length > 1 && text[0] == '/')
        {
            handleCommand(text);
            return;
        }

        if (currentDisplay == currentServer)
        {
            auto spacePos = text.indexOf(" ");
            if (spacePos != -1)
            {
                auto recipient = text[0 .. spacePos].strip();
                auto message = text[spacePos .. $].strip();
                auto msg = GuiToIrcMessage(GuiToIrcMessage.Type.Message, recipient, message, "");
                sendToIrcThread(currentServer, msg);
            }
            else
            {
                appendSystemMessage("Usage: nick message (for private messages)");
            }
        }
        else if (currentDisplay.startsWith("#"))
        {
            auto msg = GuiToIrcMessage(GuiToIrcMessage.Type.Message, currentDisplay, text, "");
            sendToIrcThread(currentServer, msg);
        }
        else
        {
            appendSystemMessage("Cannot send message to this tab.");
        }
    }

private:
    void setApplicationTheme(bool darkMode)
    {
        import core.stdcpp.new_;

        if (darkMode)
        {
            isDarkTheme = true;

            auto darkPalette = cpp_new!QPalette(QApplication.style().standardPalette());

            darkPalette.setColor(qt.gui.palette.QPalette.ColorRole.Window, QColor(53, 53, 53));
            darkPalette.setColor(qt.gui.palette.QPalette.ColorRole.WindowText, qt.core.namespace.GlobalColor.white);
            darkPalette.setColor(qt.gui.palette.QPalette.ColorRole.Base, QColor(25, 25, 25));
            darkPalette.setColor(qt.gui.palette.QPalette.ColorRole.AlternateBase, QColor(53, 53, 53));
            darkPalette.setColor(qt.gui.palette.QPalette.ColorRole.Text, qt.core.namespace.GlobalColor.white);
            darkPalette.setColor(qt.gui.palette.QPalette.ColorRole.Button, QColor(53, 53, 53));
            darkPalette.setColor(qt.gui.palette.QPalette.ColorRole.ButtonText, qt.core.namespace.GlobalColor.white);
            darkPalette.setColor(qt.gui.palette.QPalette.ColorRole.Highlight, QColor(42, 130, 218));
            darkPalette.setColor(qt.gui.palette.QPalette.ColorRole.HighlightedText, qt.core.namespace.GlobalColor.black);

            QApplication.setPalette(*darkPalette);
        }
        else
        {
            isDarkTheme = false;
            QApplication.setPalette(QApplication.style().standardPalette());
        }

        appendSystemMessage("Switched to " ~ (darkMode ? "dark" : "light") ~ " theme");
    }

    void startConnection(string server)
    {
        if (server in serverThreads)
        {
            appendSystemMessage("Already connected to " ~ server ~ ".");
            return;
        }

        auto tid = spawn(&runIrcServer, server, thisTid);
        serverThreads[server] = tid;

        if (!(server in displayBuffers))
        {
            displayBuffers[server] = "";
        }

        addServerToTree(server);

        currentDisplay = server;
        currentServer = server;
        ui.chatView.setPlainText(QString(displayBuffers[server]));
        scrollToEnd();

        appendSystemMessage("Connecting to " ~ server ~ "...");
        ui.statusBar.showMessage(QString("Connecting to " ~ server ~ "..."));

        if (!displayHistory.canFind(server))
        {
            displayHistory ~= server;
        }
    }

    void disconnectFromServer()
    {
        if (currentServer.length == 0 || !(currentServer in serverThreads))
        {
            return;
        }

        auto tid = serverThreads[currentServer];
        auto msg = GuiToIrcMessage(GuiToIrcMessage.Type.UpdateChannels, "", "", "quit");
        send(tid, msg);

        Thread.sleep(100.msecs);

        removeServerFromTree(currentServer);
        serverThreads.remove(currentServer);

        appendSystemMessage("Disconnected from " ~ currentServer ~ ".");
        ui.statusBar.showMessage(QString("Disconnected"));

        currentServer = "";
        currentDisplay = "System";
        ui.chatView.setPlainText(QString(displayBuffers["System"]));
        scrollToEnd();
    }

    void disconnectAllServers()
    {
        foreach (server, tid; serverThreads)
        {
            auto msg = GuiToIrcMessage(GuiToIrcMessage.Type.UpdateChannels, "", "", "quit");
            send(tid, msg);
        }

        Thread.sleep(150.msecs);

        ui.channelTree.clear();
        serverThreads = null;

        appendSystemMessage("Disconnected from all servers.");
        ui.statusBar.showMessage(QString("Disconnected"));

        currentDisplay = "System";
        currentServer = "";
        ui.chatView.setPlainText(QString(displayBuffers["System"]));
        scrollToEnd();
    }

    void processIrcMessage(IrcToGuiMessage msg)
    {
        final switch (msg.type)
        {
            case IrcToGuiType.chatMessage:
                auto data = msg.chat;
                string display = data.channel.length > 0 ? data.channel : data.server;
                appendChatMessage(display, data.timestamp, 
                                data.prefix ~ data.rawNick, 
                                data.messageType, data.body);
                break;

            case IrcToGuiType.channelUpdate:
                auto u = msg.channelUpdate;
                updateChannelList(u.server, u.channel, u.action);
                break;

            case IrcToGuiType.systemMessage:
                auto sysMsg = msg.systemMsg;
                if (currentServer.length > 0)
                    appendChatMessage(currentServer, formatTimestampNow(), "", "system", sysMsg.text);
                else
                    appendChatMessage("System", formatTimestampNow(), "", "system", sysMsg.text);
                break;

            case IrcToGuiType.channelTopic:
                auto topicData = msg.topicData;
                handleChannelTopic(topicData.server, topicData.channel, topicData.topic);
                break;
        }
    }

    void addServerToTree(string server)
    {
        import core.stdcpp.new_;

        auto item = cpp_new!QTreeWidgetItem();
        item.setText(0, QString(server));
        item.setData(0, qt.core.namespace.ItemDataRole.UserRole, QVariant(QString("server")));
        ui.channelTree.addTopLevelItem(item);
        ui.channelTree.expandItem(item);
    }

    void addChannelToTree(string server, string channel)
    {
        import core.stdcpp.new_;

        for (int i = 0; i < ui.channelTree.topLevelItemCount(); i++)
        {
            auto serverItem = ui.channelTree.topLevelItem(i);
            auto serverData = serverItem.text(0).toUtf8().constData();
            string serverName = serverData[0 .. serverItem.text(0).toUtf8().length()].idup;

            if (serverName == server)
            {
                auto item = cpp_new!QTreeWidgetItem();
                item.setText(0, QString(channel));
                item.setData(0, qt.core.namespace.ItemDataRole.UserRole, QVariant(QString("channel")));
                serverItem.addChild(item);
                ui.channelTree.expandItem(serverItem);
                break;
            }
        }
    }

    void removeChannelFromTree(string server, string channel)
    {
        for (int i = 0; i < ui.channelTree.topLevelItemCount(); i++)
        {
            auto serverItem = ui.channelTree.topLevelItem(i);
            auto serverData = serverItem.text(0).toUtf8().constData();
            string serverName = serverData[0 .. serverItem.text(0).toUtf8().length()].idup;

            if (serverName == server)
            {
                for (int j = 0; j < serverItem.childCount(); j++)
                {
                    auto child = serverItem.child(j);
                    auto childData = child.text(0).toUtf8().constData();
                    string childName = childData[0 .. child.text(0).toUtf8().length()].idup;

                    if (childName == channel)
                    {
                        serverItem.takeChild(j);
                        return;
                    }
                }
            }
        }
    }

    void removeServerFromTree(string server)
    {
        for (int i = 0; i < ui.channelTree.topLevelItemCount(); i++)
        {
            auto serverItem = ui.channelTree.topLevelItem(i);
            auto serverData = serverItem.text(0).toUtf8().constData();
            string serverName = serverData[0 .. serverItem.text(0).toUtf8().length()].idup;

            if (serverName == server)
            {
                ui.channelTree.takeTopLevelItem(i);
                return;
            }
        }
    }

    void handleChannelTopic(string server, string channel, string topic)
    {
        if (!(server in channelTopics))
            channelTopics[server] = null;

        channelTopics[server][channel] = topic;

        if (channel in displayBuffers)
            appendChatMessage(channel, formatTimestampNow(), "", "system", "Topic: " ~ topic);
        else
            appendChatMessage(server, formatTimestampNow(), "", "system", "Topic for " ~ channel ~ ": " ~ topic);
    }

    void updateChannelList(string server, string channel, string action)
    {
        if (action == "join")
        {
            addChannelToTree(server, channel);

            if (!(channel in displayBuffers))
                displayBuffers[channel] = "";

            if (autoSwitchToNewChannels)
            {
                currentDisplay = channel;
                if (currentDisplay in displayBuffers)
                {
                    ui.chatView.setPlainText(QString(displayBuffers[currentDisplay]));
                    scrollToEnd();
                }
            }

            if (!displayHistory.canFind(channel))
                displayHistory ~= channel;

            if (server in channelTopics && channel in channelTopics[server])
            {
                string topic = channelTopics[server][channel];
                appendChatMessage(channel, formatTimestampNow(), "", "system", "Topic: " ~ topic);
            }
        }
        else if (action == "part")
        {
            removeChannelFromTree(server, channel);

            size_t idx = -1;
            for (size_t i = 0; i < displayHistory.length; i++)
            {
                if (displayHistory[i] == channel)
                {
                    idx = i;
                    break;
                }
            }
            if (idx != -1)
                displayHistory = displayHistory[0 .. idx] ~ displayHistory[idx + 1 .. $];

            if (currentDisplay == channel)
            {
                if (displayHistory.length > 0)
                    currentDisplay = displayHistory[$ - 1];
                else
                    currentDisplay = "System";

                if (currentDisplay in displayBuffers)
                {
                    ui.chatView.setPlainText(QString(displayBuffers[currentDisplay]));
                    scrollToEnd();
                }
            }

            if (server in channelTopics)
                channelTopics[server].remove(channel);
        }
    }

    void handleCommand(string text)
    {
        if (text.startsWith("/connect "))
        {
            auto server = text["/connect ".length .. $].strip();
            startConnection(server);
        }
        else if (text.startsWith("/join "))
        {
            auto channel = text["/join ".length .. $].strip();
            if (!channel.startsWith("#"))
                channel = "#" ~ channel;

            appendSystemMessage("Joining " ~ channel);
            auto msg = GuiToIrcMessage(GuiToIrcMessage.Type.UpdateChannels, channel, "", "join");
            sendToIrcThread(currentServer, msg);
            updateChannelList(currentServer, channel, "join");
        }
        else if (text.startsWith("/part "))
        {
            auto channel = text["/part ".length .. $].strip();
            appendSystemMessage("Leaving " ~ channel);
            auto msg = GuiToIrcMessage(GuiToIrcMessage.Type.UpdateChannels, channel, "", "part");
            sendToIrcThread(currentServer, msg);
            updateChannelList(currentServer, channel, "part");
        }
        else if (text.startsWith("/whois "))
        {
            auto target = text["/whois ".length .. $].strip();
            if (currentServer.length > 0 && currentServer in serverThreads)
            {
                auto msg = GuiToIrcMessage(GuiToIrcMessage.Type.UpdateChannels, target, "", "whois");
                sendToIrcThread(currentServer, msg);
                appendChatMessage(currentDisplay, formatTimestampNow(), "", "system", "WHOIS request sent for " ~ target);
            }
            else
            {
                appendSystemMessage("Not connected to a server.");
            }
        }
        else if (text.startsWith("/disconnect"))
        {
            disconnectFromServer();
        }
        else if (text.startsWith("/quit"))
        {
            disconnectAllServers();
            appendSystemMessage("Goodbye!");
            QApplication.quit();
        }
        else if (text.startsWith("/msg ") || text.startsWith("/query "))
        {
            auto rest = text["/msg ".length .. $].strip();
            auto spacePos = rest.indexOf(" ");
            if (spacePos != -1)
            {
                auto recipient = rest[0 .. spacePos].strip();
                auto message = rest[spacePos .. $].strip();
                auto msg = GuiToIrcMessage(GuiToIrcMessage.Type.Message, recipient, message, "");
                sendToIrcThread(currentServer, msg);
            }
            else
            {
                appendSystemMessage("Usage: /msg nick message");
            }
        }
        else if (text.startsWith("/me "))
        {
            if (currentDisplay.startsWith("#"))
            {
                auto action = text["/me ".length .. $];
                string actionMsg = "\x01ACTION " ~ action ~ "\x01";
                auto msg = GuiToIrcMessage(GuiToIrcMessage.Type.Message, currentDisplay, actionMsg, "");
                sendToIrcThread(currentServer, msg);
            }
            else
            {
                appendSystemMessage("/me can only be used in channels");
            }
        }
        else if (text.startsWith("/nick "))
        {
            auto newNick = text["/nick ".length .. $].strip();
            auto msg = GuiToIrcMessage(GuiToIrcMessage.Type.Message, "", "NICK " ~ newNick, "");
            sendToIrcThread(currentServer, msg);
            appendChatMessage(currentServer, formatTimestampNow(), defaultNick, "system", "Changing nickname to: " ~ newNick);
        }
        else if (text.startsWith("/help"))
        {
            appendSystemMessage("Available commands:");
            appendSystemMessage("  /connect <server> - Connect to an IRC server");
            appendSystemMessage("  /join <#channel> - Join a channel");
            appendSystemMessage("  /part [channel] - Leave current or specified channel");
            appendSystemMessage("  /whois <nickname> - Get user information");
            appendSystemMessage("  /msg <nick> <message> - Send private message");
            appendSystemMessage("  /me <action> - Send action to channel");
            appendSystemMessage("  /nick <newnick> - Change nickname");
            appendSystemMessage("  /disconnect - Disconnect from current server");
            appendSystemMessage("  /quit - Quit the application");
            appendSystemMessage("  /help - Show this help");
        }
        else
        {
            string rawCommand = text[1 .. $];
            auto msg = GuiToIrcMessage(GuiToIrcMessage.Type.Message, "", rawCommand, "");
            sendToIrcThread(currentServer, msg);

            if (currentDisplay.startsWith("#"))
                appendChatMessage(currentDisplay, formatTimestampNow(), "", "system", ">>> " ~ rawCommand);
            else
                appendChatMessage(currentServer, formatTimestampNow(), "", "system", ">>> " ~ rawCommand);
        }
    }

    string formatTimestampNow()
    {
        auto now = Clock.currTime();
        return "[" ~ format("%02d:%02d", now.hour, now.minute) ~ "]";
    }

    void appendSystemMessage(string message)
    {
        appendChatMessage("System", formatTimestampNow(), "", "system", message);
    }

    void scrollToEnd()
    {
        auto cursor = ui.chatView.textCursor();
        cursor.movePosition(
            qt.gui.textcursor.QTextCursor.MoveOperation.End,
            qt.gui.textcursor.QTextCursor.MoveMode.MoveAnchor
        );
        ui.chatView.setTextCursor(cursor);
    }

    string getNickColor(string nickname)
    {
        if (!colorizeNicks)
            return isDarkTheme ? "#CCCCCC" : "#666666";

        if (nickname in nickColorCache)
            return nickColorCache[nickname];

        string normalized = nickname.strip().toLower();
        if (normalized.length == 0)
            normalized = "user";

        uint hash1 = 0;
        uint hash2 = 0x811c9dc5u;

        for (int i = 0; i < normalized.length; i++)
        {
            char c = normalized[i];
            uint pos = i + 1;
            hash1 = ((hash1 << 5) + hash1) + c * pos;
            hash2 ^= c * (pos * 31);
            hash2 *= 0x01000193u;
        }

        uint combined = hash1 ^ hash2;
        combined ^= combined >> 16;
        combined *= 0x85ebca6bu;
        combined ^= combined >> 13;
        combined *= 0xc2b2ae35u;
        combined ^= combined >> 16;

        float hue = cast(float)(combined % 360);
        hue = hue * 0.618033988749895f;
        hue = fmod(hue, 360.0f);

        string color;
        if (isDarkTheme)
        {
            float saturation = 0.85f;
            float lightness = 0.65f;
            uint varHash = (combined >> 8) & 0xFF;
            saturation += 0.1f * (cast(float) varHash / 255.0f);
            lightness += 0.1f * (cast(float)((combined >> 16) & 0xFF) / 255.0f);
            color = hslToHex(hue, saturation, lightness);
        }
        else
        {
            float saturation = 0.9f;
            float lightness = 0.45f;
            uint varHash = (combined >> 8) & 0xFF;
            saturation += 0.05f * (cast(float) varHash / 255.0f);
            lightness += 0.1f * (cast(float)((combined >> 16) & 0xFF) / 255.0f);
            color = hslToHex(hue, saturation, lightness);
        }

        nickColorCache[nickname] = color;
        return color;
    }

    string hslToHex(float h, float s, float l)
    {
        h = fmod(h, 360.0f);
        if (h < 0) h += 360.0f;
        s = s < 0.0f ? 0.0f : (s > 1.0f ? 1.0f : s);
        l = l < 0.0f ? 0.0f : (l > 1.0f ? 1.0f : l);

        float c = (1.0f - abs(2.0f * l - 1.0f)) * s;
        float x = c * (1.0f - abs(fmod(h / 60.0f, 2.0f) - 1.0f));
        float m = l - c / 2.0f;
        float r, g, b;

        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        r += m; g += m; b += m;
        r = r < 0.0f ? 0.0f : (r > 1.0f ? 1.0f : r);
        g = g < 0.0f ? 0.0f : (g > 1.0f ? 1.0f : g);
        b = b < 0.0f ? 0.0f : (b > 1.0f ? 1.0f : b);

        int ri = cast(int)(r * 255);
        int gi = cast(int)(g * 255);
        int bi = cast(int)(b * 255);

        return "#" ~ format("%02X%02X%02X", ri, gi, bi);
    }

    string getModeSymbolColor(char modeSymbol)
    {
        switch (modeSymbol)
        {
            case '@': return isDarkTheme ? "#FF4444" : "#D32F2F";
            case '%': return isDarkTheme ? "#FF9800" : "#F57C00";
            case '+': return isDarkTheme ? "#4CAF50" : "#388E3C";
            case '&': return isDarkTheme ? "#2196F3" : "#1976D2";
            case '~': return isDarkTheme ? "#9C27B0" : "#7B1FA2";
            default:  return isDarkTheme ? "#CCCCCC" : "#666666";
        }
    }

    void appendChatMessage(string display, string timestamp, string nickname, string type, string message)
    {
        if (display.length == 0)
            return;

        if (!(display in displayBuffers))
            displayBuffers[display] = "";

        string formattedLine;

        formattedLine ~= timestamp ~ " ";

        char modeSymbol = '\0';
        string baseNickname = nickname;

        if (nickname.length > 0 && (nickname[0] == '@' || nickname[0] == '+' || nickname[0] == '%' || nickname[0] == '&' || nickname[0] == '~'))
        {
            modeSymbol = nickname[0];
            baseNickname = nickname[1 .. $];
        }

        switch (type)
        {
            case "message":
                if (nickname.length > 0)
                {
                    if (modeSymbol != '\0')
                    {
                        string color = getModeSymbolColor(modeSymbol);
                        formattedLine ~= "<span style='color: " ~ color ~ "; font-weight: bold;'>" ~ [modeSymbol].idup ~ "</span>";
                    }

                    if (colorizeNicks)
                    {
                        string color = getNickColor(baseNickname);
                        formattedLine ~= "<span style='color: " ~ color ~ "; font-weight: bold;'>" ~ baseNickname ~ "</span>";
                    }
                    else
                    {
                        formattedLine ~= baseNickname;
                    }

                    formattedLine ~= ": " ~ message ~ "\n";
                }
                else
                {
                    formattedLine ~= message ~ "\n";
                }
                break;

            case "action":
                formattedLine ~= "* ";
                if (nickname.length > 0)
                {
                    if (modeSymbol != '\0')
                    {
                        string color = getModeSymbolColor(modeSymbol);
                        formattedLine ~= "<span style='color: " ~ color ~ "; font-weight: bold;'>" ~ [modeSymbol].idup ~ "</span>";
                    }

                    if (colorizeNicks)
                    {
                        string color = getNickColor(baseNickname);
                        formattedLine ~= "<span style='color: " ~ color ~ "; font-weight: bold;'>" ~ baseNickname ~ "</span>";
                    }
                    else
                    {
                        formattedLine ~= baseNickname;
                    }

                    formattedLine ~= " " ~ message ~ "\n";
                }
                else
                {
                    formattedLine ~= " " ~ message ~ "\n";
                }
                break;

            case "notice":
                formattedLine ~= "-";
                if (nickname.length > 0)
                {
                    if (modeSymbol != '\0')
                    {
                        string color = getModeSymbolColor(modeSymbol);
                        formattedLine ~= "<span style='color: " ~ color ~ "; font-weight: bold;'>" ~ [modeSymbol].idup ~ "</span>";
                    }

                    if (colorizeNicks)
                    {
                        string color = getNickColor(baseNickname);
                        formattedLine ~= "<span style='color: " ~ color ~ "; font-weight: bold;'>" ~ baseNickname ~ "</span>";
                    }
                    else
                    {
                        formattedLine ~= baseNickname;
                    }

                    formattedLine ~= "- " ~ message ~ "\n";
                }
                else
                {
                    formattedLine ~= "- " ~ message ~ "\n";
                }
                break;

            case "join": case "part": case "quit": case "kick": case "nick":
                if (nickname.length > 0)
                {
                    if (modeSymbol != '\0')
                    {
                        string color = getModeSymbolColor(modeSymbol);
                        formattedLine ~= "<span style='color: " ~ color ~ "; font-weight: bold;'>" ~ [modeSymbol].idup ~ "</span>";
                    }

                    if (colorizeNicks)
                    {
                        string color = getNickColor(baseNickname);
                        formattedLine ~= "<span style='color: " ~ color ~ "; font-weight: bold;'>" ~ baseNickname ~ "</span>";
                    }
                    else
                    {
                        formattedLine ~= baseNickname;
                    }

                    formattedLine ~= " " ~ message ~ "\n";
                }
                else
                {
                    formattedLine ~= message ~ "\n";
                }
                break;

            case "system":
                string color = isDarkTheme ? "#AAAAAA" : "#555555";
                formattedLine ~= "<span style='color: " ~ color ~ ";'>" ~ message ~ "</span>\n";
                break;

            default:
                if (nickname.length > 0)
                {
                    if (colorizeNicks)
                    {
                        string color = getNickColor(baseNickname);
                        formattedLine ~= "<span style='color: " ~ color ~ "; font-weight: bold;'>" ~ baseNickname ~ "</span>";
                    }
                    else
                    {
                        formattedLine ~= baseNickname;
                    }

                    formattedLine ~= ": " ~ message ~ "\n";
                }
                else
                {
                    formattedLine ~= message ~ "\n";
                }
                break;
        }

        displayBuffers[display] ~= formattedLine;

        if (display == currentDisplay)
        {
            ui.chatView.insertHtml(QString(formattedLine));
            scrollToEnd();
        }
    }

    void appendWelcomeMessage()
    {
        appendSystemMessage("Welcome to D IRC Client!");
        appendSystemMessage("Type /connect <server> to connect to an IRC server");
        appendSystemMessage("Type /join #channel to join a channel");
        appendSystemMessage("Type /whois <nickname> for user information");
        appendSystemMessage("Type /help for more commands");
    }

    private void logDebug(T...)(T args)
    {
        import std.stdio : stderr;

        foreach (arg; args)
        {
            stderr.write(to!string(arg), " ");
        }
        stderr.writeln();
    }
}
